plugins {
    id 'com.jfrog.bintray' version "1.8.4"
    id 'com.sarhanm.versioner' version '3.0.21'
    id 'com.gradle.plugin-publish' version '0.12.0'
    id 'jacoco'
    id 'com.github.kt3k.coveralls' version '2.6.3'
}

group = 'com.sarhanm'

apply plugin: 'java-gradle-plugin'
apply plugin: 'groovy'
apply plugin: 'eclipse'
apply plugin: 'maven'
apply plugin: 'maven-publish'

versioner{
    //Community Plugins are required to have a clean version string.
    omitBranchMetadataOnSolidBranch=true
}

repositories {
    jcenter()
}

dependencies {
    compile gradleApi()
    compile localGroovy()


    compile 'org.yaml:snakeyaml:1.21'
    compile 'io.github.http-builder-ng:http-builder-ng-apache:1.0.3'

    testCompile gradleTestKit()
    testCompile ('org.spockframework:spock-core:1.1-groovy-2.4'){
        exclude group: 'org.codehaus.groovy'
    }

    testCompile 'com.netflix.nebula:nebula-test:7.2.3'
}

jacocoTestReport {
    reports {
        xml.enabled = true // coveralls plugin depends on xml format report
        html.enabled = true
    }
}

wrapper{
    gradleVersion = '5.1'
}

task sourcesJar(type: Jar) {
    classifier = 'sources'
    from sourceSets.main.allSource
}
task groovydocJar( type: Jar ) {
    classifier 'javadoc'
    from groovydoc
}

artifacts {
    archives sourcesJar
    archives groovydocJar
}

publishing {
    publications {
        mavenJava(MavenPublication) {
            from components.java
            artifact sourcesJar
            artifact groovydocJar
        }
    }
}

bintray {
    user = 'sarhanm'
    key = System.env.BINTRAYTOKEN
    publications = ['mavenJava']
    dryRun = false
    publish = true
    pkg {
        repo = 'maven'
        name = 'gradle-versioner'
        desc = 'A gradle plugin to set the project version based on git metadata'
        websiteUrl = 'https://github.com/sarhanm/gradle-versioner'
        issueTrackerUrl = 'https://github.com/sarhanm/gradle-versioner/issues'
        vcsUrl = 'https://github.com/sarhanm/gradle-versioner.git'
        licenses = ['MIT']
        labels = ['gradle', 'git', 'versioning', 'auto version' ,'versioner', 'version', 'versioning']
        publicDownloadNumbers = true
        version {
            name = project.version
            attributes = ['gradle-plugin': ['com.sarhanm.versioner:com.sarhanm:gradle-versioner','com.sarhanm.version-resolver:com.sarhanm:gradle-versioner'] ]
        }
    }
}

gradlePlugin {
    plugins.create("gradle-versioner") {
        id = "com.sarhanm.versioner"
        implementationClass = "com.sarhanm.versioner.VersionerPlugin"
    }
}

pluginBundle {
  website = 'https://github.com/sarhanm/gradle-versioner/wiki'
  vcsUrl = 'https://github.com/sarhanm/gradle-versioner'

  description = 'Set the project version based on git metadata and number of commits.'
  tags = ['versioner', 'version', 'versioning', 'git', 'scm', 'commits', 'auto version', 'auto', 'gradle']

  plugins {

    versionerPlugin {
      id = 'com.sarhanm.versioner'
      displayName = 'Gradle Project Version Set Plugin'
      description = 'Set the project version based on git metatdata and number of commits. Example: 1.0.81.master.efbb95a'
    }

    versionResolverPlugin {
      id = 'com.sarhanm.version-resolver'
      displayName = 'Version Resolver: Resolve Dependencies From Global Manifest'
      description = 'Allows you to resolve versions for all dependencies from a global manifest rather than hard coding versions in each build.gradle file.'
    }
  }
}

/**
 * Grabs the values from the env and writes to a file that can be used by the plugin-publish plugin.
 * This allows us define the API and secrete securely in travis-ci
 */
task setupPluginUpload {
    doLast {
        def key = System.env.gradlePublishKey
        def secret = System.env.gradlePublishSecret

        if (!key || !secret) {
            throw new RuntimeException("gradlePublishKey and/or gradlePublishSecret are not defined environment variables")
        }

        System.properties.setProperty("gradle.publish.key", key)
        System.properties.setProperty("gradle.publish.secret", secret)
    }
}

tasks.publishPlugins.dependsOn tasks.setupPluginUpload

// If we want our unit tests to work in intellij/eclipse, then we need to change
// where our build output goes so its the same on the command line and in intellij.
// This is because the java-gradle-plugin generates a meta-data file used in testing,
// and that meta-data files adds build/classes/main to the classpath.
if(System.properties.getProperty("local-eclipse", "true") == "true") {
    project.plugins.withType(EclipsePlugin) {
        project.eclipse {
            classpath {
                defaultOutputDir = project.file("${project.buildDir}/classes/main")
            }
        }
    }
}
